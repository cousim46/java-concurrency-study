# 프로세스 & 스레드

## 프로세스
- 운영체제에 의해 파일 시스템에 설치되어 있는 파일을 프로그램이라고 부른다.
- 프로세스는 프로그램의 실제 실행의 의미하며 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태.
- 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위.

![img.png](img.png)

- 운영체제는 프로세마다 각각 독립된 메모리 영역을 Code/Data/Heap/Stack의 형식으로 할당.
- 독립된 메모리 영역을 할당해주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있음.
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없고 IPC나 공유메모리 등의 통신기법들을 사용해서 프로세스 간 통신해야 함.

![img_1.png](img_1.png)

## 스레드
- 스레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행단위 또는 흐름의 단위로서 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
- 프로세스 내에서 각 필요한 Stack만 할당받고 Code/Data/Heap 영역은 공유해서 각 스레드가 공유한다.
- 스레드 간 메모리 스택 영역에 접근할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게 되어 독립적인 함수 호출이 가능해진다.

![img_2.png](img_2.png)


## 스레드 & CPU
- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU의 최소 실행단위를 의미.
- 스케줄러의 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU에 할당됨.
- 스레드 간 선점이 일어날때 CPU의 실행흐름(문맥)이 전환되는 컨텍스트 스위칭이 발생

![img_3.png](img_3.png)

## 프로세스 VS 스레드

### 프로세스
- 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에게 영향을 미치지 않는다. 즉 프로그램 전체의 안전성을 확보 가능
- 프로세스 간 전환(컨텍스트 스위칭) 시 레지스터, 캐시 메모리 초기화 등 무거운 작업으로 인한 시간적인 비용이 많이 발생
- 프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 큼
- 프로세스 생성 시 독립적으로 메모리가 할당되기 때문에 리소스 비용이 큼

### 스레드
- 여러개의 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미치게 된다.
- 프로세스의 메모리 영역을 공유하기 때문에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용
- 스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다.
- 스레드 간 공유 메모리 영역의 동시 접근으로 인한 동기화 문제가 발생한다.
- 하나의 스레드에서 오류가 발생할경우 프로세스 자체가 종료될 수 있다


# 동시성 & 병렬성

## 개요
- 동시성 : 특정한 순서 없이 겹치는 기간에 시작, 실행 및 완료 되는 여러 작업에 관한것을 의미
- 병렬성 : 멀티코어 프로세서에서 동시에 실행되는 동일한 작업의 여러 


## 동시성
- CPU가 한번에 많은 일을 처리하는것에 중점. 즉 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 처리.
- 작업의 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점을 둔다.
  - 스레드가 작업을 처리하다가 I/O 블록에 걸렸을경우 CPU는 다른 스레드로 전환해서 작업을 진행 -> I/O에 대한 작업은 CPU담당이 아니기 때문에 I/O 블록으로 인해 대기하기보다는 다른 스레드로 전환해서 작업을 진행하는것이 효율적
- 작업에 대한 처리 방식을 어떤식으로 진핼할것인가에 대한 설계적 관점에서 이해해야 함.
- 작업해야할 수가 CPU 코어 수보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행해야함.
  ![img_4.png](img_4.png)

## 병렬성
- CPU가 동시에 많은 일을 수행하는것에 중점을 둔다. 즉 CPU가 놀지 않고 최대한 바쁘게 동작해야함.
-  런타임에 동시에 물리적으로 작업을 실행하는것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요하다. 한개의 코어에서는 절대 병렬성 구현될 수 없다.
- 동시성의 하위 개념으로 여러 작업을 여러 스레드로 분리하고 운영체제는 그 스레드를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는것
- 동시성이 작업 처리방식에 대한 설계에 관한것이라면 병렬성은 하드웨어에 계층에서 작업 수행방식에 관한것
- 작업해야할 수가 CPU 코어 수보다 같거나 적을 경우 가장 효율

![img_5.png](img_5.png)


## 병렬성과 동시성 조합

### ThreadPoolExecutor
- 병렬성으로 처리 성능을 극대화 하고 동시성으로 CPU 자원을 효율적으로 운용한다.

![img_6.png](img_6.png)

## Parallelism - Divide and Conquer

### ForkJoinPool
- 하나의 태스크를 서브 태스크로 분할하여 병렬처리함으로써 전체 작업 성능을 높임

![img_7.png](img_7.png)


# Context Switch

## 개요
- 하나의 CPU는 동일한 시간에 하나의 작업(Task)만 수행할 수 있기때문에 여러 프로세스를 동시에 실행할 수 없다.
- 하나의 CPU에서 여러 프로세스를 동시성으로 처리하기 위해서는 한 프로세스에서 다른 프로세스로 전환해야하는데 이것을 컨텍스트 스위치리라고 함.

## Context(문맥)
- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register에는 어떤 값이 저장되어 있는지에 대한 정보가 필요함.
- Context는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 이 정보들은 운영체제가 관리하는 PCB라고 하는 자료구조의 공간에 저장됨

## PCB(Process Control Block)
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조
- 컨텍스트 스위칭은 CPU가 프로세스 간 PCB정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있다.

![img_8.png](img_8.png)

## 프로세스 상태
- 프로세스는 New(생성), 준비(Ready), 실행(Running), Blocked(대기), Exit(종료) 상태를 가진다.

![img_9.png](img_9.png)

- New : 프로세스를 생성하고 있는 단계로 커널 영역에 PCB가 만들어진 상태
- Ready : 프로세스가 CPU를 할당받기 위해 기다리고 있는 상태
- Running : 프로세스가 CPU를 할당받아 명령어를 실행중인 상태
- Waiting: 프로세스가 I/O 작업 완료 혹은 사건 발생을 기다리는 상태
- Terminated: 프로세스가 종료된 상태

## 컨텍스트 스위칭이 일어나는 조건
- 실행중인 프로세스에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때까지 프로세스 상태가 Running에서 Waiting 상태로 전이된 경우
- Round Robin 스케쥴링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 잇는 시간 자원을 모두 사용했을 때 해당 프로세스를 중지하고 (ready 상태로 전이) 다른 프로세스를 실행시켜주는 경우

![img_10.png](img_10.png)


## 스레드 컨텍스트 스위칭

### TCB(Thread Control Block)
- Thread 상태정보를 저장하는 자료구조이며, PC와 Register Set(CPU 정보), 그리고 PCB를 가리키는 포인터를 가짐
- 스레드가 하나 생성될 때마다 PCB내에서 TCB가 생성되며 컨텍스트 스위칭이 일어나면 기존 스레드 TCB를 저장하고 새로운 TCB를 가져와실행



### 프로세스 vs 스레드
- 프로세스는 컨텍스트 스위칭 할 때 메모리 주소 관련 여러가지 처리(CPU 캐시 초기화, TLB 초기화 등..)를 하기 때문에 오버헤드가 큼
- 스레드는 프로세스 내 메모리를 공유하기 때문에 메모리 주소 관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아서 컨텍스트 스위칭이 빠름.
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 애플리케이션 성능이 저하될 수 있음.


# CPU Bound VS I/O Bound

## 개요
- 프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행됩니다.
- 프로세스는 CPU 명령어를 수행하다가 I/O를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행
- 특정한 태스크가 완료될때까지 이를 반복

## Burst
- 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행할 것

### CPU Burst
- CPU를 연속적으로 사용하면서 명령어를 실행하는 구간을 의미
- 프로세스가 CPU 명령어를 실행하는데 소비하는 시간
- 프로세스의 RUNNING 상태를 처리


### I/O Burst
- 연속적으로 I/O 실행하는 구간으로 I/O작업이 수행되는 동안 대기하는 구간
- 프로세스가 I/O 요청 완료를 기다리는데 걸리는 시간
- 프로세스 WATING 상태를 처리

![img_11.png](img_11.png)

- 프로세스마다 CPU 버스트와 I/O버스트가 차지하는 비율이 균일하지 않다.
- 이 비율을 기준으로 해서 CPU 바운드 프로세스와 I/O 바운드 프로세스로 나눌 수 있다.

## CPU Bounded Prodcess
- CPU Burst 작입어 많은 프로세스로서 I/O Burst가 거의 없는 경우에 해당한다.
- 머신러닝, 블록체인, 동영상 편집 프로그램 등 CPU 연산 위주의 작업을 하는 경우를 의미.
- 멀티 코어의 병렬성을 최대한 활용해서 처리 성능을 극대화 하도록 스레드를 운용한다. 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정

![img_12.png](img_12.png)

## I/O Bounded Process
- I/O Burst가 빈번히 발생하는 프로세스로서 CPU Burst 매우 짧다
- 파일, 키보드, DB, 네트워크 등 외부 연결이나 입출력 장치와의 통신 작없이 많은 경우에 해당
- CPU코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU가 Idle 상태가 되지 않도록 하고 최적화된 스레드 수를 운용해서 CPU의 효율적인 사용을 극대화한다.

![img_13.png](img_13.png)

# 사용자 모드 & 커널모드

## 개요
- 운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이다.
- 운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널(Kernel)이라고 한다.

![img_14.png](img_14.png)

- 운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는것을 방지하여 자원을 보호합니다.
  - 응용 프로그램이 하드웨어 자원에 직접 접근해서 조작할 수 있다면 자원 관리가 되지 않고 프로세스 간 데이터가 훼손되어 컴퓨터 시스템 전체에 오류를 가져오게 됩니다.
  - 응용 프로그램이 하드웨어 자원에 접근하려고 할 때는 반드시 운영체제를 통해서만 접근하도록 해야합니다.

## CPU 권한모드
- CPU는 명령어를 실행할때 사용자 모드와 커널로 구분합니다.
- CPU는 동작하는 동안 두가지 모드를 번갈아가면서 실행을 합니다.

## 사용자모드(Mode Bit = 1)
- 사용자 응용프로그램의 코드가 실행되는 모드로서 메모리의 유저 영역만 접근 가능
- 디스크, 메모리, Printer 및 여러 I/O 장치들과 같은 특정 리소스들에 직접 접근할 수 없다.
- 대부분의 응용프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 이때는 유저모드에서 커널모드로 전환되어야 한다.

## 커널모드 (Mode Bit = 0) 
- 커널 영역의 코드가 실행 되는 모드로서 메모리의 유저영역, 커널영역 모두 접근 가능
- 하드웨어 자원에 직접 접근할 수 있

## 사용자모드에서 커널모드로 변환하는 방법 -> 시스템 호출
- 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이
- 응용 프로그램이 파일 입출력이나, 화면에 메시지를 출력하는 등의 기능은 커널 모드일때 CPU가 실행하기 때문에 반드시 시스템 콜을 사용해서 커널모드로 전화해야 함.

![img_15.png](img_15.png)

## 시스템 호출 동작 과정
- 사용자 응용프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고 이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 됨.
- I/O 처리를 위해 사용자 모드와 커널 모드를 번갈아 오가는것은 컨텍스트 스위칭과 관련이 있으며 이는 멀티 스레드 환경에서 참고해야 할 중요한 배경지식

![img_16.png](img_16.png)

# 사용자 수준 스레드 & 커널 수준 스레드

## 개요
- 스레드는 크게 두가지 유형으로 구분하는데 사용자 수준 스레드(User Level Thread)와 커널 수준 스레드로 구분됨.
- 사용자 수준 스레드는 사용자 프로그램에서 관리하는 스레드이며 커널 수준 스레드는 OS에서 관리하는 스레드이다.

## 사용자 수준 스레드(User Level Thread)
- 사용자 수준 스레드란 사용자 영역에서 스레드 라이브러리(Pthreads, Windows Threads, Java Threads(JVM))에 의해 스레드의 생성과 종료, 스레드 간 메시지 전달, 스레드의 스케쥴링 보관 등 모든것을 관리한다.
- 커널은 사용자 수준 스레드에 대해 알지 못하며 단일 스레드 프로세스인 것처럼 관리

## 커널 수준 스레드(Kernel Level Thread)
- 커널 수준 스레드란 커널이 스레드와 관련된 모든 작업을 관리(PCB, TCB 관리/유지)
- 커널은 커널 스레드의 모든 정보를 알고 있으며 커널 스레드는 OS 스케줄러에 의해서 스케줄링 된다.
- CPU는 커널에 의해 생성된 커널 스레드의 실행만 담당한다.


## 멀티스레딩 모델
- CPU는 OS Scheduler가 예약하는 커널 스레드만 할당 받아 실행시키기 때문에 사용자 수준 스레드는 커널 수준 스레드와의 매핑이 필요하다.
- 사용자 수준 스레드는 세가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있습니다.
  - 다대일 스레드 매핑, 일대일 스레드 매핑, 다대다 스레드 매핑

### 다대일 스레드 매핑(many to one thread mapping)
- "다수의" 사용자 수준 스레드가 커널 수준 스레드 "한개"에 매핑하는 유형으로 사용자 수준의 스레드 모델이라 볼 수 있다.

![img_17.png](img_17.png)

- 커널 개입 없이 사용자 스레드끼리의 컨텍스트 스위칭이 발생하기 때문에 오버헤드가 적다.
- 스케쥴링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어든다.
- 개별 스레드 단위가 아닌 단일 스레드의 프로세스 단위로 프로세서를 할당하기 때문에 멀티 코어를 활용한 병렬처리를 할 수 없다.
- 한 스레드가 Block I/O가 발생하면 모든 스레드들이 Block이 발생하는데 이는 프로세스 자체를 블록하기 때문이다.
- 자바에서 초기버전의 Green Thread가 이 모델에 해당한다고 볼 수 있다.


### 일대일 스레드 매핑(one to one thread mapping)
- 사용자 수준 스레드와 커널 수준 스레드가 일대일로 매핑하는 유형으로 커널 수준의 스레드 모델이라 볼 수 있습니다.

![img_18.png](img_18.png)

- 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭시 사용자모드에서 커널 모드로 전환해서 스케줄링 하는 등의 오버헤드가 발생
- 자원 한정으로 인해 스레드를 무한정으로 생성할 수 없다. 대안으로 스레드 풀을 활용하기도 함.
- 스레드 단위로 CPU를 할당하기 때문에 멀티 코어를 활용한 병렬 처리가 가능함.
- 스레드 중 한개가 대기 상태가 되더라도 다른 스레드를 실행할 수 있다. 즉 멀티스레드의 동시성을 활용할 수 잇다.
- 자바에서 Native Thread가 이 모델에 해당.

### 다대다 스레드 매핑(many to many thread mapping)
- 여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형
- 각 커널 수준의 스레드가 사용자 수준의 스레드 한개 이상과 매핑된다.
- 다대다 모델은 다대일, 일대일 모델의 단점을 어느정도 해결하여, 개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있고 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다.
- 사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을때 커널이 다른 스레드의 수행을 스케줄 할 수 있다.

![img_19.png](img_19.png)
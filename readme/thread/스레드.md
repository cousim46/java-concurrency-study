# 스레드 생성
## 개요
- 자바 스레드는 JVM에서 사용자 수준 스레드(User Thread)를 생성할 때 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑이 되어 최종적으로 커널에서 관리된다.
- JVM에서 스레드를 생성할때마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다.
- 자바에서는 Platform Thread로 정의되어 있다 .즉 OS 플랫폼에 따라 JVM이 사용자 스레드를 매핑하게 된다.

![img.png](img.png)

## Thread 구조
![img_1.png](img_1.png)

## 스레드 생성 하는 방법

1. Thread 클래스 상속하는 방법

![img_2.png](img_2.png)

- 작업 내용을 스레드 내부에 직접 재정의해서 실행

2. Runnable 인터페이스를 구현하는 방법

![img_3.png](img_3.png)

- 작업내용을 Runnable에 정의해서 스레드에 전달하면 스레드는 Runnable을 실행


## 다양한 스레드 생성 패턴

1. Thread 클래스 상속하는 방법
- 가장 기본적인 방식이며 Thread 클래스를 반드시 상속받아야 한다.
- 상속의 특성상 컴파일 타임 시점에 실행코드가결정되어 동적인 기능 변경이 불가능하다는 단점이 있음.

2. Thread 익명 클래스

![img_4.png](img_4.png)

- 스레드 객체를 참조하거나 재활용하지 않고 일회용으로만 사용할 겨웅

3. Runnable 인터페이스를 구현하는 방법
- Runnable을 태스크로 활용하는 방식으로서 선호하는 방식
- 스레드와 실행하고자 하는 태스크를 분리함으로써 좀 더 유연하고 확장 가능한 구조로 구현이 가능

4. Ruunable 익명 클래스

![img_5.png](img_5.png)

- Runnable 타입을 참조하거나 재활용하지 않고 일회용으로만 사용할 경우

5. Runnable 람다 방식

![img_7.png](img_7.png)

- Runnable을 람다 형식으로 구현함으로써 코드가 간결해진다.


# 스레드 실행 및 종료 - start() & run()



## 개요
- 자바 스레드는 운영체제 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM에서 제어할 수 없습니다.
- 새로운 스레드는 현재 스레드와 독립적으로 실행되고 최대 한번 시작할 수 있고 스레드가 종료된 후에는 다시 시작할 수 없습니다.

## 스레드 실행
- start() : 스레드를 실행키는 메서드로 시스템 콜을 통해서 커널에 커널 스레드 생성을 요청

![img_8.png](img_8.png)

1) 메인스레드가 새로운 스레드를 생성합니다.
2) 메인스레드가 start() 메서드를 호출해서 스레드 실행을 시작합니다.
3) 내부적으로 네이티브 메서드인 start()를 호출해서 커널에게 커널 스레드를 생성하도록 시스템 콜을 요청합니다.(native가 붙은 메서드는 java에서 어떤 API를 수행하려는 것이 아니라 그 밑단의 커널 또는 운영체제의 도움을 받기 위해서 시스템 콜을 요청하기 위한 메서드입니다.)
4) 커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1:1 매핑이 이루어집니다.
5) 커널 스레드는 OS 스케줄러로부터 CPU 할당을 받기까지 실행대기 상태에 있습니다.
6) 커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM에서 매핑된 자바 스레드의 run() 메서드를 호출합니다.


- run()
  - 스레드 실행이 되면 해당 스레드에 의해 자동으로 호출되는 메서드입니다.
  - Thread의 run이 자동 호출되고 여기서 Runnable 구현체가 존재할경우 Runnable의 run()을 실행하게 됩니다.
  - public static void main(String[] args)가 메인스레드에 의해 자동으로 호출되는것과 비슷한 원리입니다.
  - 주의할것은 만약 start가 아닌 run() 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run()이 실행될뿐입니다.

```java
Thread thread = new WokerThread();
thread.run();
```
![img_9.png](img_9.png)

```java
Thread thread = new WokerThread();
thread.start();
```

![img_10.png](img_10.png)

## 스레드 스택(Stack)
- 스레드가 생성되면 해당 스레드를 위한 스택이 같이 만들어진다.
- 스택은 각 스레드마다 독립적으로 할당되어 작동하기 때문에 스레드 간 접근하거나 공유할 수 없고 이는 스레드로부터 안전하다고 할 수 있습니다.
- 스택은 운영체제에 따라 크기가 주어지고 크기를 넘기게 되면 StackOverFlowError 발생합니다.

![img_11.png](img_11.png)

## 스택의 구성 정보
- 스택에 대한 메모리 접근은 Push & Pop에 의한 후입선출(LIFO) 순서로 이루어지며 스택은 프레임(Frame)으로 구성되어 있습니다.
- 프레임은 새 메서드를 호출할때마다 로컬변수(지역변수, 파라미터) 및 객체 참조변수와 함께 스택의 맨 위에 생성(push)되고 메서드 실행이 완료되면 해당 스택 프레임이 제거(pop) 되고 흐름이 호출한 메서드로 돌아가며 공간이 다음 메서드에 사용 가능해집니다.

```java
public void method1() {
    method2();
}
public void method2() {
    method3();
}
public int method3() {
    return 1;
}
```

![img_12.png](img_12.png)

## 스레드 종료
- 스레드는 run() 메서드의 코드가 모두 실행되면 스레드는 자동으로 종료한다.
- 스레드는 예외가 발생할 경우 종료되며 다른 스레드에 영향을 미치지 않습니다.
- 어플리케이션은 싱글 스레드인 경우와 멀티스레드인 경우 종료 기준이 다릅니다.

### 싱글 스레드

![img_13.png](img_13.png)

- 싱글스레드는 사용자스레드가 없는 기본 main thread만 있는 상태입니다.
- main thread만 종료되면 어플리케이션이 종료됩니다.

### 멀티 스레드

![img_14.png](img_14.png)

- 멀티스레드인 경우 JVM에서 실행하고 있는 모든 스레드가 종료되어야 어플리케이션이 종료됩니다.
- 동일한 코드를 실행하는 각 스레드의 종료 시점은 처리 시간 및 운영체제의 스케줄링에 의해 결정되므로 매번 다르게 나올 수 있습니다.


스레드 유형이 데몬 스레드일 경우 위 내용과 일부 다른점이 존재